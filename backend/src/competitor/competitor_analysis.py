#!/usr/bin/env python3
"""
Competitor Analysis Data Generator
Analyzes pain point comparisons among 6 competing products using data generated by category_feedback_analyzer.py

Target products:
- Leviton D26HD
- Leviton D215S  
- Lutron Caseta Diva
- TP Link Switch
- Leviton DSL06
- Lutron Diva

Usage:
    python competitor_analysis.py

Output:
    Generates frontend/lib/competitorAnalysis.ts file
"""

import json
import os
import sys
import pandas as pd
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional, Set
import re


class CompetitorAnalyzer:
    def __init__(self, data_dir: str):
        """
        Initialize competitor analyzer using data generated by category_feedback_analyzer.py
        
        Args:
            data_dir: Data directory path containing JSON files
        """
        self.data_dir = Path(data_dir)
        self.consolidated_data = None
        self.expanded_reviews = None
        self.category_definitions = None
        self.product_mapping = None
        
        # Define 6 target products with exact ASIN matching (exact ASIN list provided by user)
        self.target_products = {
            'Leviton D26HD': {
                'asins': ['B0BVKYKKRK'],
                'brand': 'Leviton',
                'type': 'Smart Dimmer'
            },
            'Leviton D215S': {
                'asins': ['B0BVKZLT3B'],
                'brand': 'Leviton', 
                'type': 'Smart Switch'
            },
            'Lutron Caseta Diva': {
                'asins': ['B0BSHKS26L'],
                'brand': 'Lutron',
                'type': 'Smart Dimmer'
            },
            'TP Link Switch': {
                'asins': ['B01EZV35QU'],
                'brand': 'TP-Link',
                'type': 'Smart Switch'
            },
            'Leviton DSL06': {
                'asins': ['B00NG0ELL0'],
                'brand': 'Leviton',
                'type': 'Traditional Dimmer'
            },
            'Lutron Diva': {
                'asins': ['B085D8M2MR'],
                'brand': 'Lutron',
                'type': 'Traditional Dimmer'
            }
        }
        
        # Result data: product × category pain point matrix
        self.product_pain_matrix = {}
        self.product_use_case_matrix = {}  # Add use case matrix
        
    def load_product_mapping(self):
        """Load target product data using exact ASIN matching"""
        print("Loading target products using exact ASIN matching...")
        
        # First load expanded_review_results to get actual review counts
        expanded_file = self.data_dir / "expanded_review_results.json"
        if not expanded_file.exists():
            raise FileNotFoundError(f"File not found: {expanded_file}")
        
        with open(expanded_file, 'r', encoding='utf-8') as f:
            expanded_data = json.load(f)
        
        # Exact matching of target product ASINs
        self.product_mapping = {}
        matched_products = {product: [] for product in self.target_products.keys()}
        
        for product_name, criteria in self.target_products.items():
            for target_asin in criteria['asins']:
                if target_asin in expanded_data.get('results', {}):
                    product_info = expanded_data['results'][target_asin]
                    actual_reviews = product_info.get('total_reviews', 0)
                    
                    self.product_mapping[target_asin] = {
                        'product_name': product_name,
                        'title': product_info.get('product_title', ''),
                        'brand': criteria['brand'],
                        'type': criteria['type'],
                        'total_reviews': actual_reviews
                    }
                    matched_products[product_name].append({
                        'asin': target_asin,
                        'title': product_info.get('product_title', ''),
                        'total_reviews': actual_reviews
                    })
                else:
                    print(f"⚠️  ASIN {target_asin} ({product_name}) not found in review data")
        
        # Print matching results
        print("✓ Exact ASIN matching results (actual review counts):")
        for product_name, matches in matched_products.items():
            if matches:
                for match in matches:
                    print(f"  {product_name}: {match['asin']} - {match['total_reviews']} reviews")
                    print(f"    └─ {match['title'][:80]}...")
            else:
                print(f"  {product_name}: ❌ No data found")
        
        total_matched = sum(len(matches) for matches in matched_products.values())
        total_reviews = sum(match['total_reviews'] for matches in matched_products.values() for match in matches)
        print(f"Total exact matches: {total_matched} target products, total reviews: {total_reviews}")
        
    def load_data(self):
        """Load required data files"""
        print("Loading data files...")
        
        # Load product mapping
        self.load_product_mapping()
        
        # Load consolidated aspect categorization
        consolidated_file = self.data_dir / "consolidated_aspect_categorization.json"
        if not consolidated_file.exists():
            raise FileNotFoundError(f"File not found: {consolidated_file}")
        
        with open(consolidated_file, 'r', encoding='utf-8') as f:
            self.consolidated_data = json.load(f)
        print(f"✓ Loaded consolidated_aspect_categorization.json")
        
        # Load expanded review results
        expanded_file = self.data_dir / "expanded_review_results.json"
        if not expanded_file.exists():
            raise FileNotFoundError(f"File not found: {expanded_file}")
        
        with open(expanded_file, 'r', encoding='utf-8') as f:
            self.expanded_reviews = json.load(f)
        print(f"✓ Loaded expanded_review_results.json")
        
        # Load product type mapping from category_feedback_analyzer
        product_mapping_file = self.data_dir / "product_type_mapping.json"
        if product_mapping_file.exists():
            with open(product_mapping_file, 'r', encoding='utf-8') as f:
                self.category_product_mapping = json.load(f)
            print(f"✓ Loaded product_type_mapping.json")
        else:
            print("⚠️  product_type_mapping.json not found, will generate basic mapping")
            self.category_product_mapping = {}
        
    def extract_rating_score(self, rating_str: str) -> float:
        """Extract numeric rating from rating string"""
        try:
            if isinstance(rating_str, str) and "out of 5 stars" in rating_str:
                return float(rating_str.split()[0])
            return 0.0
        except (ValueError, IndexError):
            return 0.0
            
    def analyze_competitor_pain_points(self):
        """Analyze competitor pain point matrix: product × category using category feedback data structure"""
        print("Analyzing competitor pain point matrix...")
        
        # Initialize data structure for each target product
        for product_name in self.target_products.keys():
            self.product_pain_matrix[product_name] = defaultdict(lambda: {
                'mentions': 0,
                'positive_reviews': [],
                'negative_reviews': [],
                'category_type': '',
                'satisfaction_rate': 0.0
            })
        
        # Count processing for each product type
        processed_count = {product: 0 for product in self.target_products.keys()}
        
        # Process all products
        total_products = len(self.consolidated_data['results'])
        processed_products = 0
        
        for product_id, product_data in self.consolidated_data['results'].items():
            processed_products += 1
            if processed_products % 50 == 0:
                print(f"  Processing progress: {processed_products}/{total_products}")
            
            # Check if this is a target product
            if product_id not in self.product_mapping:
                continue
                
            # Check if corresponding data exists in expanded_reviews
            if product_id not in self.expanded_reviews.get('results', {}):
                continue
                
            product_name = self.product_mapping[product_id]['product_name']
            processed_count[product_name] += 1
            expanded_product = self.expanded_reviews['results'][product_id]
            
            # Process phy and perf categories
            for category_type in ['phy', 'perf']:
                if category_type not in product_data['aspect_categorization']:
                    continue
                    
                # Iterate through aspect groups
                for aspect_group_name, aspect_group in product_data['aspect_categorization'][category_type].items():
                    for aspect_key, category_name in aspect_group.items():
                        if category_name == "OUT_OF_SCOPE":
                            continue
                        
                        # Record category type
                        category_full_name = f"{category_name}"
                        self.product_pain_matrix[product_name][category_full_name]['category_type'] = 'Physical' if category_type == 'phy' else 'Performance'
                        
                        # Find corresponding review data
                        review_analysis = expanded_product.get('review_analysis', {})
                        if category_type not in review_analysis:
                            continue
                            
                        type_analysis = review_analysis[category_type]
                        if aspect_group_name not in type_analysis:
                            continue
                            
                        group_analysis = type_analysis[aspect_group_name]
                        if aspect_key not in group_analysis:
                            continue
                            
                        aspect_reviews = group_analysis[aspect_key]
                        
                        # Process positive and negative reviews - only count mentions if we have sentiment data
                        found_sentiment = False
                        for sentiment in ['+', '-']:
                            if sentiment not in aspect_reviews:
                                continue
                                
                            reviews_list = aspect_reviews[sentiment]
                            if not isinstance(reviews_list, list):
                                continue
                                
                            found_sentiment = True
                                
                            for review in reviews_list:
                                if not isinstance(review, dict):
                                    continue
                                    
                                rating_score = self.extract_rating_score(review.get('rating', ''))
                                review_data = {
                                    'rating': rating_score,
                                    'sentiment': sentiment,
                                    'aspect_key': aspect_key,
                                    'product_id': product_id
                                }
                                
                                if sentiment == '+':
                                    self.product_pain_matrix[product_name][category_full_name]['positive_reviews'].append(review_data)
                                elif sentiment == '-':
                                    self.product_pain_matrix[product_name][category_full_name]['negative_reviews'].append(review_data)
                        
                        # Only count as mention if we found sentiment data
                        if found_sentiment:
                            self.product_pain_matrix[product_name][category_full_name]['mentions'] += 1
        
        print("✓ Product processing statistics:")
        for product, count in processed_count.items():
            print(f"  {product}: {count} product instances")
        
    def calculate_satisfaction_rates(self):
        """Calculate satisfaction rate for each product-category combination"""
        print("Calculating satisfaction metrics...")
        
        for product_name, categories in self.product_pain_matrix.items():
            for category_name, data in categories.items():
                positive_count = len(data['positive_reviews'])
                negative_count = len(data['negative_reviews'])
                total_reviews = positive_count + negative_count
                
                if total_reviews > 0:
                    satisfaction_rate = (positive_count / total_reviews) * 100
                    data['satisfaction_rate'] = round(satisfaction_rate, 1)
                    data['positive_count'] = positive_count
                    data['negative_count'] = negative_count
                    data['total_reviews'] = total_reviews
                else:
                    data['satisfaction_rate'] = 0.0
                    data['positive_count'] = 0
                    data['negative_count'] = 0
                    data['total_reviews'] = 0
    
    def analyze_competitor_use_cases(self):
        """Analyze competitor use case matrix: product × use case using use case data structure"""
        print("Analyzing competitor use case matrix...")
        
        # Initialize data structure for each target product
        for product_name in self.target_products.keys():
            self.product_use_case_matrix[product_name] = defaultdict(lambda: {
                'mentions': 0,
                'positive_reviews': [],
                'negative_reviews': [],
                'satisfaction_rate': 0.0,
                'gap_level': 0  # Will be calculated based on satisfaction
            })
        
        # Count processing for each product type
        processed_count = {product: 0 for product in self.target_products.keys()}
        
        # Process all products
        total_products = len(self.consolidated_data['results'])
        processed_products = 0
        
        for product_id, product_data in self.consolidated_data['results'].items():
            processed_products += 1
            if processed_products % 50 == 0:
                print(f"  Processing progress: {processed_products}/{total_products}")
            
            # Check if this is a target product
            if product_id not in self.product_mapping:
                continue
                
            # Check if corresponding data exists in expanded_reviews
            if product_id not in self.expanded_reviews.get('results', {}):
                continue
                
            product_name = self.product_mapping[product_id]['product_name']
            processed_count[product_name] += 1
            expanded_product = self.expanded_reviews['results'][product_id]
            
            # Process use cases
            if 'use' not in product_data['aspect_categorization']:
                continue
                
            use_categorization = product_data['aspect_categorization']['use']
            
            # Get corresponding review data
            review_analysis = expanded_product.get('review_analysis', {})
            if 'use' not in review_analysis:
                continue
                
            use_reviews = review_analysis['use']
            
            # Process each use case
            for use_case_key, final_category in use_categorization.items():
                if final_category == "OUT_OF_SCOPE":
                    continue
                
                # Use the final category name as the use case name
                use_case_name = final_category
                
                # Find corresponding review data
                if use_case_key not in use_reviews:
                    continue
                    
                use_case_reviews = use_reviews[use_case_key]
                
                # Process positive and negative reviews - only count mentions if we have sentiment data
                found_sentiment = False
                for sentiment in ['+', '-']:
                    if sentiment not in use_case_reviews:
                        continue
                        
                    sentiment_data = use_case_reviews[sentiment]
                    
                    # Handle different data structures for use cases vs other categories
                    reviews_list = []
                    if isinstance(sentiment_data, list):
                        # Standard format: list of review objects
                        reviews_list = sentiment_data
                    elif isinstance(sentiment_data, dict):
                        # Use case format: dictionary with 'l' and 'w' keys
                        # Extract reviews from all sub-keys
                        for key, value in sentiment_data.items():
                            if isinstance(value, list):
                                reviews_list.extend(value)
                            elif isinstance(value, dict):
                                # Handle nested structures if needed
                                pass
                    
                    if not reviews_list:
                        continue
                        
                    found_sentiment = True
                        
                    for review in reviews_list:
                        if not isinstance(review, dict):
                            continue
                            
                        rating_score = self.extract_rating_score(review.get('rating', ''))
                        review_data = {
                            'rating': rating_score,
                            'sentiment': sentiment,
                            'use_case_key': use_case_key,
                            'product_id': product_id
                        }
                        
                        if sentiment == '+':
                            self.product_use_case_matrix[product_name][use_case_name]['positive_reviews'].append(review_data)
                        elif sentiment == '-':
                            self.product_use_case_matrix[product_name][use_case_name]['negative_reviews'].append(review_data)
                
                # Only count as mention if we found sentiment data
                if found_sentiment:
                    self.product_use_case_matrix[product_name][use_case_name]['mentions'] += 1
        
        print("✓ Use case processing statistics:")
        for product, count in processed_count.items():
            print(f"  {product}: {count} product instances")
    
    def calculate_use_case_satisfaction_rates(self):
        """Calculate satisfaction rate and gap level for each product-use case combination"""
        print("Calculating use case satisfaction metrics...")
        
        for product_name, use_cases in self.product_use_case_matrix.items():
            for use_case_name, data in use_cases.items():
                positive_count = len(data['positive_reviews'])
                negative_count = len(data['negative_reviews'])
                total_reviews = positive_count + negative_count
                
                if total_reviews > 0:
                    satisfaction_rate = (positive_count / total_reviews) * 100
                    data['satisfaction_rate'] = round(satisfaction_rate, 1)
                    data['positive_count'] = positive_count
                    data['negative_count'] = negative_count
                    data['total_reviews'] = total_reviews
                    # Calculate gap level (inverse of satisfaction rate)
                    data['gap_level'] = round(100 - satisfaction_rate, 1)
                else:
                    data['satisfaction_rate'] = 0.0
                    data['positive_count'] = 0
                    data['negative_count'] = 0
                    data['total_reviews'] = 0
                    data['gap_level'] = 100.0  # High gap if no data
    
    def get_matrix_data(self) -> List[Dict]:
        """Get matrix data format for frontend matrix display, including all 6 target products"""
        matrix_data = []
        
        # Include all 6 target products, excluding none
        valid_products = list(self.target_products.keys())
        
        print(f"✓ Including all target products: {valid_products}")
        
        # Calculate mention ratios for each category within each product
        from collections import defaultdict
        category_ratios_by_product = defaultdict(dict)  # {product: {category: ratio}}
        
        for product_name in valid_products:
            if product_name not in self.product_pain_matrix:
                continue
            
            categories = self.product_pain_matrix[product_name]
            total_mentions_for_product = sum(data.get('mentions', 0) for data in categories.values())
            
            # Calculate ratio for each category within this product
            for category_name, data in categories.items():
                mentions = data.get('mentions', 0)
                ratio = (mentions / total_mentions_for_product * 100) if total_mentions_for_product > 0 else 0
                category_ratios_by_product[product_name][category_name] = ratio
        
        # Calculate average mention ratio for each category across all products
        all_categories = set()
        for product_ratios in category_ratios_by_product.values():
            all_categories.update(product_ratios.keys())
        
        category_avg_ratios = {}
        for category_name in all_categories:
            ratios = []
            for product_name in valid_products:
                if product_name in category_ratios_by_product:
                    ratio = category_ratios_by_product[product_name].get(category_name, 0)
                    ratios.append(ratio)
            
            avg_ratio = sum(ratios) / len(ratios) if ratios else 0
            category_avg_ratios[category_name] = avg_ratio
        
        # Select top 10 categories by average mention ratio
        top_categories = sorted(category_avg_ratios.items(), 
                               key=lambda x: x[1], 
                               reverse=True)[:10]
        
        valid_categories = [cat[0] for cat in top_categories]
        
        print(f"✓ Selected top 10 categories by average mention ratio:")
        for i, (cat, avg_ratio) in enumerate(top_categories, 1):
            print(f"    {i:2d}. {cat}: {avg_ratio:.1f}% average mention ratio")
        
        # Generate data points for each product-category combination, including empty values to maintain matrix completeness
        for product_name in valid_products:
            for category_name in valid_categories:
                data = self.product_pain_matrix.get(product_name, {}).get(category_name, {
                    'mentions': 0,
                    'satisfaction_rate': 0.0,
                    'category_type': 'Physical',
                    'positive_count': 0,
                    'negative_count': 0,
                    'total_reviews': 0
                })
                
                # Include all data points, including 0-mention data to maintain matrix completeness
                matrix_data.append({
                    'product': product_name,
                    'category': category_name,
                    'categoryType': data.get('category_type', 'Physical'),
                    'mentions': data.get('mentions', 0),
                    'satisfactionRate': data.get('satisfaction_rate', 0.0),
                    'positiveCount': data.get('positive_count', 0),
                    'negativeCount': data.get('negative_count', 0),
                    'totalReviews': data.get('total_reviews', 0)
                })
        
        return matrix_data
    
    def get_summary_stats(self) -> Dict:
        """Get summary statistics"""
        total_data_points = 0
        total_mentions = 0
        satisfaction_rates = []
        
        for product_name, categories in self.product_pain_matrix.items():
            for category_name, data in categories.items():
                if data.get('mentions', 0) >= 0:  # Include all data points
                    total_data_points += 1
                    total_mentions += data.get('mentions', 0)
                    if data.get('total_reviews', 0) > 0:  # Only calculate satisfaction for data with actual reviews
                        satisfaction_rates.append(data.get('satisfaction_rate', 0.0))
        
        avg_satisfaction = sum(satisfaction_rates) / len(satisfaction_rates) if satisfaction_rates else 0
        
        return {
            'totalProducts': len(self.target_products),
            'totalDataPoints': total_data_points,
            'totalMentions': total_mentions,
            'avgSatisfactionRate': round(avg_satisfaction, 1),
            'processingDate': datetime.now().isoformat(),
            'description': '6 product competitive pain points analysis including all target products'
        }
    
    def generate_typescript_file(self, output_path: str):
        """Generate TypeScript data file"""
        print(f"Generating TypeScript file: {output_path}")
        
        # Get matrix data and summary statistics
        matrix_data = self.get_matrix_data()
        use_case_matrix_data = self.get_use_case_matrix_data()
        summary_stats = self.get_summary_stats()
        
        # Group data by category type
        physical_data = [d for d in matrix_data if d['categoryType'] == 'Physical']
        performance_data = [d for d in matrix_data if d['categoryType'] == 'Performance']
        
        # Collect actual total review count for each product
        product_total_reviews = {}
        for asin, mapping in self.product_mapping.items():
            product_name = mapping['product_name']
            total_reviews = mapping.get('total_reviews', 0)
            if product_name not in product_total_reviews:
                product_total_reviews[product_name] = 0
            product_total_reviews[product_name] += total_reviews
        
        # Generate TypeScript code
        ts_content = f'''// Competitor Analysis Data - 6 product competitive pain point analysis (including all products)
// Data source: consolidated_aspect_categorization.json, expanded_review_results.json
// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// Products analyzed: Leviton D26HD, D215S, Lutron Caseta Diva, TP Link Switch, Leviton DSL06, Lutron Diva (including all products)

export interface ProductPainPoint {{
  product: string;                    // Product name
  category: string;                   // Category name
  categoryType: 'Physical' | 'Performance'; // Category type
  mentions: number;                   // Mention count (for bubble size)
  satisfactionRate: number;           // Satisfaction percentage (for color)
  positiveCount: number;              // Positive review count
  negativeCount: number;              // Negative review count
  totalReviews: number;               // Total review count
}}

export interface ProductUseCaseData {{
  product: string;
  useCase: string;
  mentions: number;
  satisfactionRate: number;
  positiveCount: number;
  negativeCount: number;
  totalReviews: number;
  gapLevel: number; // From actual analysis data
}}

export interface CompetitorAnalysisData {{
  summary: {{
    totalProducts: number;
    totalDataPoints: number;
    totalMentions: number;
    avgSatisfactionRate: number;
    processingDate: string;
    description: string;
  }};
  matrixData: ProductPainPoint[];        // Complete matrix data
  physicalData: ProductPainPoint[];     // Physical characteristics data
  performanceData: ProductPainPoint[];  // Performance characteristics data
  targetProducts: string[];             // Target product list
  productTotalReviews: Record<string, number>; // Actual total review count per product
}}

// Target product list (including all 6 products)
export const targetProducts = {json.dumps(list(self.target_products.keys()), indent=2, ensure_ascii=False)};

// Actual total review count per product
export const productTotalReviews = {json.dumps(product_total_reviews, indent=2, ensure_ascii=False)};

// Summary statistics
export const competitorSummary = {json.dumps(summary_stats, indent=2, ensure_ascii=False)};

// Complete pain point matrix data
export const competitorMatrixData: ProductPainPoint[] = {json.dumps(matrix_data, indent=2, ensure_ascii=False)};

// Physical characteristics pain point data
export const physicalPainPoints: ProductPainPoint[] = {json.dumps(physical_data, indent=2, ensure_ascii=False)};

// Performance characteristics pain point data
export const performancePainPoints: ProductPainPoint[] = {json.dumps(performance_data, indent=2, ensure_ascii=False)};

// Use case matrix data
export const useCaseMatrixData: ProductUseCaseData[] = {json.dumps(use_case_matrix_data, indent=2, ensure_ascii=False)};

// Get competitor analysis data
export function getCompetitorAnalysisData(): CompetitorAnalysisData {{
  return {{
    summary: competitorSummary,
    matrixData: competitorMatrixData,
    physicalData: physicalPainPoints,
    performanceData: performancePainPoints,
    targetProducts: targetProducts,
    productTotalReviews: productTotalReviews
  }};
}}

// Get use case analysis data
export function getUseCaseAnalysisData(): {{
  matrixData: ProductUseCaseData[];
  targetProducts: string[];
  productTotalReviews: Record<string, number>;
}} {{
  return {{
    matrixData: useCaseMatrixData,
    targetProducts: targetProducts,
    productTotalReviews: productTotalReviews
  }};
}}

// Get pain point data for specified product
export function getProductPainPoints(productName: string): ProductPainPoint[] {{
  return competitorMatrixData.filter(item => item.product === productName);
}}

// Get all product data for specified category
export function getCategoryComparisonData(categoryName: string): ProductPainPoint[] {{
  return competitorMatrixData.filter(item => item.category === categoryName);
}}

// Get all category list
export function getAllCategories(): string[] {{
  const categories = new Set(competitorMatrixData.map(item => item.category));
  return Array.from(categories).sort();
}}

// Get data filtered by category type
export function getDataByType(categoryType: 'Physical' | 'Performance'): ProductPainPoint[] {{
  return competitorMatrixData.filter(item => item.categoryType === categoryType);
}}

// Calculate satisfaction color mapping (for matrix display)
export function getSatisfactionColor(satisfactionRate: number): string {{
  if (satisfactionRate >= 85) return '#22c55e';      // Green - high satisfaction
  else if (satisfactionRate >= 70) return '#eab308'; // Yellow - medium satisfaction
  else if (satisfactionRate >= 60) return '#f97316'; // Orange - lower satisfaction
  else return '#ef4444';                              // Red - low satisfaction
}}

// Calculate bubble size mapping
export function getBubbleSize(mentions: number, maxMentions: number): number {{
  const minSize = 10;
  const maxSize = 50;
  const normalizedSize = (mentions / maxMentions) * (maxSize - minSize) + minSize;
  return Math.max(minSize, Math.min(maxSize, normalizedSize));
}}
'''
        
        # Write file
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(ts_content)
        
        print(f"✓ Generated TypeScript file: {output_path}")
    
    def print_analysis_summary(self):
        """Print analysis results summary"""
        print("\n" + "="*80)
        print("Competitor Analysis Results Summary (including all 6 target products)")
        print("="*80)
        
        matrix_data = self.get_matrix_data()
        summary = self.get_summary_stats()
        
        print(f"Target product count: {summary['totalProducts']}")
        print(f"Total data points: {summary['totalDataPoints']}")
        print(f"Total mentions: {summary['totalMentions']}")
        print(f"Average satisfaction: {summary['avgSatisfactionRate']}%")
        
        print(f"\nProduct data distribution:")
        for product_name in self.target_products.keys():
            product_data = [d for d in matrix_data if d['product'] == product_name]
            total_mentions = sum(d['mentions'] for d in product_data)
            avg_satisfaction = sum(d['satisfactionRate'] for d in product_data if d['totalReviews'] > 0) / len([d for d in product_data if d['totalReviews'] > 0]) if [d for d in product_data if d['totalReviews'] > 0] else 0
            print(f"  {product_name:<20}: {len(product_data):3d} categories, {total_mentions:4d} mentions, {avg_satisfaction:5.1f}% satisfaction")
        
        print(f"\nCategory type distribution:")
        physical_count = len([d for d in matrix_data if d['categoryType'] == 'Physical'])
        performance_count = len([d for d in matrix_data if d['categoryType'] == 'Performance'])
        print(f"  Physical: {physical_count} data points")
        print(f"  Performance: {performance_count} data points")
        
        print("\n" + "="*80)
    
    def get_use_case_matrix_data(self) -> List[Dict]:
        """Get use case matrix data format for frontend matrix display"""
        use_case_matrix_data = []
        
        # Include all 6 target products
        valid_products = list(self.target_products.keys())
        
        print(f"✓ Processing use cases for products: {valid_products}")
        
        # Calculate mention ratios for each use case within each product
        from collections import defaultdict
        use_case_ratios_by_product = defaultdict(dict)  # {product: {use_case: ratio}}
        
        for product_name in valid_products:
            if product_name not in self.product_use_case_matrix:
                continue
            
            use_cases = self.product_use_case_matrix[product_name]
            total_mentions_for_product = sum(data.get('mentions', 0) for data in use_cases.values())
            
            # Calculate ratio for each use case within this product
            for use_case_name, data in use_cases.items():
                mentions = data.get('mentions', 0)
                ratio = (mentions / total_mentions_for_product * 100) if total_mentions_for_product > 0 else 0
                use_case_ratios_by_product[product_name][use_case_name] = ratio
        
        # Calculate average mention ratio for each use case across all products
        all_use_cases = set()
        for product_ratios in use_case_ratios_by_product.values():
            all_use_cases.update(product_ratios.keys())
        
        use_case_avg_ratios = {}
        for use_case_name in all_use_cases:
            ratios = []
            for product_name in valid_products:
                if product_name in use_case_ratios_by_product:
                    ratio = use_case_ratios_by_product[product_name].get(use_case_name, 0)
                    ratios.append(ratio)
            
            avg_ratio = sum(ratios) / len(ratios) if ratios else 0
            use_case_avg_ratios[use_case_name] = avg_ratio
        
        # Select top 10 use cases by average mention ratio
        top_use_cases = sorted(use_case_avg_ratios.items(), 
                              key=lambda x: x[1], 
                              reverse=True)[:10]
        
        valid_use_cases = [uc[0] for uc in top_use_cases]
        
        print(f"✓ Selected top 10 use cases by average mention ratio:")
        for i, (uc, avg_ratio) in enumerate(top_use_cases, 1):
            print(f"    {i:2d}. {uc}: {avg_ratio:.1f}% average mention ratio")
        
        # Generate data points for each product-use case combination
        for product_name in valid_products:
            for use_case_name in valid_use_cases:
                data = self.product_use_case_matrix.get(product_name, {}).get(use_case_name, {
                    'mentions': 0,
                    'satisfaction_rate': 0.0,
                    'gap_level': 100.0,
                    'positive_count': 0,
                    'negative_count': 0,
                    'total_reviews': 0
                })
                
                # Include all data points, including 0-mention data to maintain matrix completeness
                use_case_matrix_data.append({
                    'product': product_name,
                    'useCase': use_case_name,
                    'mentions': data.get('mentions', 0),
                    'satisfactionRate': data.get('satisfaction_rate', 0.0),
                    'positiveCount': data.get('positive_count', 0),
                    'negativeCount': data.get('negative_count', 0),
                    'totalReviews': data.get('total_reviews', 0),
                    'gapLevel': data.get('gap_level', 100.0)
                })
        
        return use_case_matrix_data
    
    def run(self, output_path: str):
        """Run complete analysis pipeline"""
        try:
            self.load_data()
            self.analyze_competitor_pain_points()
            self.calculate_satisfaction_rates()
            self.analyze_competitor_use_cases()
            self.calculate_use_case_satisfaction_rates()
            self.generate_typescript_file(output_path)
            self.print_analysis_summary()
            
            print(f"\n✅ Competitor analysis complete! Data saved to: {output_path}")
            
        except Exception as e:
            print(f"\n❌ Error during analysis: {str(e)}")
            raise


def main():
    """Main function"""
    # Set up paths
    current_dir = Path(__file__).parent.parent.parent  # backend/
    data_dir = current_dir / "data/result/process_review/20250609_05"
    output_path = current_dir.parent / "frontend/lib/competitorAnalysis.ts"  # frontend/lib/
    
    print("Competitor Analysis Generator - 6 Product Competitive Analysis (including all target products)")
    print("="*70)
    print(f"Data directory: {data_dir}")
    print(f"Output file: {output_path}")
    print()
    
    # Run analysis
    analyzer = CompetitorAnalyzer(str(data_dir))
    analyzer.run(str(output_path))


if __name__ == "__main__":
    main()